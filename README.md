# 问题描述
一个逻辑表达式如果对于其变元的任一种取值都为真，则称重言式；反之，如果对于其变元的任一种取值都为假，则称矛盾式；其他情形称为可满足式。编写程序，判断逻辑表达式属于哪种情形。

# 设计要求
1. 建立逻辑二叉表达式树。
2. 写一程序，根据逻辑二叉表达式树对包括逻辑变量的逻辑表达式进行重言式判别。

# 第一次设计
第一次设计的目标是实现设计要求`(1)`：建立逻辑二叉表达式树。

第一次设计可分为如下五个部分：

1. 逻辑表达式定义
2. 输入设计
3. 合法性检验
4. 可算性检验
5. 错误输出
6. 建立逻辑二叉表达式树

下面就这六个部分展开叙述。

## 逻辑表达式定义
逻辑表达式与算术表达式类似，分成运算数、运算符、括号这三个部分。在本次设计中为了方便输入，认为运算数只能是单个大写字母或者逻辑常量`0`和`1`；运算符采取离散数学中最基础的五种运算符：非、合取、析取、蕴涵、等价，在表达式中用`!`、`&`、`|`、`->`、`<->`表示；所有的括号都使用圆括号。

## 输入设计
逻辑表达式输入时也是一个字符串，因此采用与魔王语言翻译中相同的链队列存储法，对所有长度的字符串都能兼容。同时对蕴涵运算符和等价运算符进行简化，`->`简化为`>`，`<->`简化为`=`，方便之后的处理。

## 合法性检验
输入的合法性是无法保证的，因此需要对输入的表达式进行合法性检验。

表达式应该满足如下性质，否则都是非法表达式：

- 不是空表达式
- 不包含非法字符
- 括号必须全部匹配
- 括号内必须有内容

这四种性质的检验非常简单，这里不再赘述。

## 可算性检验
就算输入合法了，也无法保证表达式能够计算出结果，因此需要对输入再进行一次可算性检验。

合法表达式应该满足如下性质，否则都无法计算出结果：

- 所有括号内的表达式都可算
- 所有运算符和运算数都被正确使用
- 运算符对应的运算数都可算

这三种性质的检验较为困难，下面展开叙述。

### 可算的基本单元
可算也是一种性质，必须定义基础单元，现定义以下表达式是可算的基本单元：

- 单个逻辑变量，如`A`
- 单个逻辑常量，如`0`和`1`

因此只要是单个逻辑运算数就是可算的。

### 运算符的正确使用
五种运算符都有自己的使用方法，正确使用的方法如下表：

| 运算符 | 使用方法 | 正确示例 | 错误示例 |
| :------: | :------: | :------: | :------: |
| `!` | 放在运算数的左侧 | `!A` | `A!` |
| `&` | 放在两个运算数的中间 | `A&B` | `AB&`、`A&` |
| `\|` | 放在两个运算数的中间 | `A\|B` | `AB\|`、`A\|` |
| `->` | 放在两个运算数的中间 | `A->B` | `AB->`、`A->` |
| `<->` | 放在两个运算数的中间 | `A<->B` | `AB<->`、`A<->` |

### 可算的递归性
可算是一种递归的性质，一个表达式的可算可以这么拆分：

1. 去掉表达式最外层的匹配括号
2. 寻找最后被运算的运算符(括号外，最靠右，优先级最低)
3. 如果找不到这样的运算符，就说明不可算
4. 如果找到的运算符没有被正确使用，就说明不可算
5. 否则检验其两侧的表达式是否可算，如果都可算，说明可算，否则不可算

可算的性质由子表达式决定，因此可算性检验的函数使用递归算法。

## 错误输出
在合法性检验和可算性检验完成后，会得到一个参数，参数的值、其对应的含义以及处理方法可见下表：

| 参数值 | 参数含义 | 处理方法 |
| :------: | :------: | :------: |
| 1 | 表达式合法 | 输出信息“该表达式合法” |
| 0 | 表达式为空 | 输出错误“该表达式为空” |
| -1 | 表达式包含非法字符 | 输出错误“该表达式包含非法字符”，随后输出第一个非法字符及其位置 |
| -2 | 表达式存在左括号匹配失败 | 输出错误“该表达式存在左括号匹配失败”，随后输出第一个匹配失败的左括号的位置 |
| -3 | 表达式存在右括号匹配失败 | 输出错误“该表达式存在右括号匹配失败”，随后输出第一个匹配失败的右括号的位置 |
| -4 | 表达式存在没有内容的括号 | 输出错误“该表达式存在空括号”，随后输出第一个空括号的左括号的位置 |
| -5 | 表达式不可算 | 输出错误“该表达式不可算” |

## 建立逻辑二叉表达式树
由于二叉树是具有递归性的结构，设计时尽量考虑递归算法。

逻辑二叉表达式树具有如下特性：

1. 中序遍历后得到中缀表达式
2. 后序遍历后得到后缀表达式

输入的表达式相当于中缀版本，那如何将中缀表达式抽象成二叉树呢？

首先，每个运算符都有`1~2`个运算数，而且运算数的顺序不能随意更改，因此我们可以让运算符成为根，而左右的运算数就成为该根节点的左右子树。

而建立左右子树的方法和建立树的方法完全相同，也是运算符作根，左右运算数作左右子树。

有一些情况是可以直接成树的，如果内容为空，就返回空树；内容只有一个逻辑变量或逻辑常量，就返回以它为根、左右子树为空的二叉树。

现在写出根据中缀表达式建立逻辑二叉表达式树的过程：

1. 如果表达式被匹配的括号包裹，则去掉两端括号直到不再被括号包裹为止。
2. 如果表达式为空，则返回空树；如果只有一个逻辑变量和逻辑常量，则返回以它为根、左右子树为空的二叉树
3. 否则就寻找表达式中最后被运算的运算符(括号外、最靠右、优先级最低)。
4. 以该运算符为根，左右的子表达式对应的二叉树分别作为其左右子树

# 第二次设计
第二次设计的目标是完成根据逻辑二叉表达式树判断逻辑表达式类型的功能。

第二次设计可分为以下几个部分：

1. 变量提取
2. 特定赋值的计算
3. 判断表达式类型

下面就这三点展开叙述。

## 变量提取
由于变量的取值决定了表达式的结果，因此需要直到表达式中到底包含哪些变量。

逻辑变量就是一个大写字母，因此遇到大写字母就可以提取出来。

由于大写字母只有寥寥`26`个，因此可以使用静态数组存储出现过哪些变量。

## 特定赋值的计算
计算表达式的值的步骤如下：

1. 如果表达式仅有一个逻辑变量或逻辑常量，其值就是表达式的值
2. 如果表达式包含运算符，则将其运算数运算完成后，根据运算符的运算法则得出结果即可

明显，这又是一个具有递归性的算法，而逻辑二叉表达式树的形式完美符合要求。

各运算符的运算规则如下：

| 运算 | 运算符 | 运算规则 |
| :------: | :------: | :------: |
| 非 | `!` | `!0 = 1`, `!1 = 0` |
| 合取 | `&` | `0&0 = 0&1 = 1&0 = 0`, `1&1 = 1` |
| 析取 | `\|` | `0\|0 = 0`, `0\|1 = 1\|0 = 1\|1 = 1` |
| 蕴涵 | `->` | `0->0 = 0->1 = 1->1 = 1`, `1->0 = 0` |
| 等价 | `<->` | `0<->0 = 1<->1 = 1`, `0<->1 = 1<->0 = 0` |